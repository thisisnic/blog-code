---
title: R package documentation - what makes a good example?
author: ''
date: '2021-05-13'
slug: r-package-documentation-what-makes-a-good-example
categories:
  - R
tags:
  - documentation
---

As part of my ongoing mission to make the documentation of the arrow R package as good as it can be, I've started thinking about what makes for good examples.  I have found that example code that I can run is the best way for me to achieve rapid familiarity with a new R function, and so believe that every exported function in a package should have an accompanying example.  

## What good looks like

I asked people on Twitter for their opinions of good R package documentation, and [Jonathan Sinclair](https://twitter.com/_J_sinclair/status/1391677551261650945) highlighted `dplyr::case_when`.  

I've pasted the current version of the example code below.

```{r, eval =FALSE}
x <- 1:50
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)

# Like an if statement, the arguments are evaluated in order, so you must
# proceed from the most specific to the most general. This won't work:
case_when(
  TRUE ~ as.character(x),
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz"
)

# If none of the cases match, NA is used:
case_when(
  x %%  5 == 0 ~ "fizz",
  x %%  7 == 0 ~ "buzz",
  x %% 35 == 0 ~ "fizz buzz"
)

# Note that NA values in the vector x do not get special treatment. If you want
# to explicitly handle NA values you can use the `is.na` function:
x[2:4] <- NA_real_
case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  is.na(x) ~ "nope",
  TRUE ~ as.character(x)
)

# All RHS values need to be of the same type. Inconsistent types will throw an error.
# This applies also to NA values used in RHS: NA is logical, use
# typed values like NA_real_, NA_complex, NA_character_, NA_integer_ as appropriate.
case_when(
  x %% 35 == 0 ~ NA_character_,
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
)
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA_real_
)

# case_when() evaluates all RHS expressions, and then constructs its
# result by extracting the selected (via the LHS expressions) parts.
# In particular NaN are produced in this case:
y <- seq(-2, 2, by = .5)
case_when(
  y >= 0 ~ sqrt(y),
  TRUE   ~ y
)

# This throws an error as NA is logical not numeric
## Not run: 
case_when(
  x %% 35 == 0 ~ 35,
  x %% 5 == 0 ~ 5,
  x %% 7 == 0 ~ 7,
  TRUE ~ NA
)

## End(Not run)

# case_when is particularly useful inside mutate when you want to
# create a new variable that relies on a complex combination of existing
# variables
starwars %>%
  select(name:mass, gender, species) %>%
  mutate(
    type = case_when(
      height > 200 | mass > 200 ~ "large",
      species == "Droid"        ~ "robot",
      TRUE                      ~ "other"
    )
  )


# `case_when()` is not a tidy eval function. If you'd like to reuse
# the same patterns, extract the `case_when()` call in a normal
# function:
case_character_type <- function(height, mass, species) {
  case_when(
    height > 200 | mass > 200 ~ "large",
    species == "Droid"        ~ "robot",
    TRUE                      ~ "other"
  )
}

case_character_type(150, 250, "Droid")
case_character_type(150, 150, "Droid")

# Such functions can be used inside `mutate()` as well:
starwars %>%
  mutate(type = case_character_type(height, mass, species)) %>%
  pull(type)

# `case_when()` ignores `NULL` inputs. This is useful when you'd
# like to use a pattern only under certain conditions. Here we'll
# take advantage of the fact that `if` returns `NULL` when there is
# no `else` clause:
case_character_type <- function(height, mass, species, robots = TRUE) {
  case_when(
    height > 200 | mass > 200      ~ "large",
    if (robots) species == "Droid" ~ "robot",
    TRUE                           ~ "other"
  )
}

starwars %>%
  mutate(type = case_character_type(height, mass, species, robots = FALSE)) %>%
  pull(type)
```

I think Jonathan is spot on in his assessment.  To paraphrase, the highlights for him are that there is next to no prose or intro, plenty of comments where needed, a variety of examples, and also examples of what *not* to do.  This kind of documentation really appeals to my skim-reading self.  If I'm trying to accomplish a task, sometimes I just want to run some code and see what happens, to get an intuitive feel for what a function does.  Whilst I am fully prepared to slow down and read the rest of the documentation, a "quick win" motivates me to invest the effort.  It tells me that the developers of this code have prioritised making things easy to understand, and that the time I am investing will pay off.

I've been skimming through the documentation for some tidyverse packages - as I consider many of these to be well documented and easy to read - and here are some things I've observed which I think make the examples look great:

* using very simple or common in-built datasets
* demonstrating non-obvious behaviours of a function
* demonstrating different parameter values/combinations
* demonstrating any unusual parameters
* sometimes go beyond the use of an individual function to include common mini-workflows
* group documentation and examples for similar functions together
* examples which may lead to unexpected results

Other things which I am unsure either way about:
* showing output when it adds to the example (e.g. `tidyselect::starts_with()` and many other examples from that package)

## What bad looks like

I am not intending to "name and shame" any package authors who haven't included examples for their functions.  It may have been overlooked, there may be plenty of explanation elsewhere, or they may have felt that the code was not sufficiently complex to require examples.  It might be true that it seems obvious what a function does, but that makes a lot of assumptions about the user of your code that might not hold true.

